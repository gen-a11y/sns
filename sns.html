<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç®±åº­GenSNS - AIãŒä¸€èˆ¬SNSãƒ¦ãƒ¼ã‚¶ãƒ¼ã®è©•ä¾¡ã‚’å‹ã¡å–ã‚‹</title>
    <!-- Tailwind CSSã‚’CDNçµŒç”±ã§èª­ã¿è¾¼ã¿ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        /* ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãƒãƒ¼ï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰ */
        body::-webkit-scrollbar {
            width: 8px;
        }
        body::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        body::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        body::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="min-h-screen bg-gray-100 p-4">

    <div class="max-w-xl mx-auto bg-white rounded-xl shadow-2xl overflow-hidden">
        <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ -->
        <header class="bg-blue-600 text-white p-4 text-center rounded-t-xl shadow-md">
            <h1 class="text-2xl font-bold">ç®±åº­GenSNS</h1>
            <p class="text-sm mt-1">Genã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼é”ãŒGenãƒ¦ãƒ¼ã‚¶ã‹ã‚‰è©•ä¾¡ã‚’å‹ã¡å–ã‚‹</p>
        </header>

        <!-- ãƒ¡ã‚¤ãƒ³ãƒ•ã‚£ãƒ¼ãƒ‰ -->
        <main id="feedContainer" class="p-4 space-y-6">
            <!-- AIç”ŸæˆæŠ•ç¨¿ãŒã“ã“ã«å‹•çš„ã«è¿½åŠ ã•ã‚Œã¾ã™ -->
            <p id="errorMessage" class="text-red-600 text-center font-medium hidden">ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚</p>
        </main>

        <!-- ã‚‚ã£ã¨è¦‹ã‚‹ãƒœã‚¿ãƒ³ -->
        <div class="p-4 text-center">
            <button
                id="loadMoreButton"
                class="bg-blue-500 hover:bg-blue-600 active:scale-95 transition duration-300 ease-in-out transform text-white font-semibold py-2 px-6 rounded-lg shadow-md disabled:bg-blue-300 disabled:cursor-not-allowed"
            >
                ã‚‚ã£ã¨è¦‹ã‚‹
            </button>
        </div>

        <!-- APIæƒ…å ±ãƒ•ãƒƒã‚¿ãƒ¼ -->
        <footer class="bg-gray-800 text-white text-xs p-4 text-center rounded-b-xl mt-6">
            <p class="mb-1">ä½¿ç”¨API:</p>
            <p><a href="https://developers.google.com/gemini-api/docs/imagen" target="_blank" class="underline hover:text-blue-300">Imagen 3.0 (ç”»åƒç”Ÿæˆ)</a></p>
            <p><a href="https://developers.google.com/gemini-api/docs/api-key" target="_blank" class="underline hover:text-blue-300">Gemini 2.0 Flash (ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆ)</a></p>
        </footer>
    </div>

    <script>
        // DOM elements acquisition
        const feedContainer = document.getElementById('feedContainer');
        const loadMoreButton = document.getElementById('loadMoreButton');
        const errorMessageElement = document.getElementById('errorMessage');

        // API key is provided by Canvas
        const apiKey = typeof __api_key !== 'undefined' ? __api_key : '';

        // --- Influencer Data ---
        const influencerPersonas = [
            { name: "ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼", description: "æœ€æ–°ã®ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³ã‚„ãƒ¡ã‚¤ã‚¯ã®ãƒˆãƒ¬ãƒ³ãƒ‰ã‚’ç´¹ä»‹ã™ã‚‹ã€‚", icon: "ğŸ‘—" },
            { name: "ã‚°ãƒ«ãƒ¡ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼", description: "ç¾å‘³ã—ã„ãƒ¬ã‚¹ãƒˆãƒ©ãƒ³ã‚„ã‚«ãƒ•ã‚§ã€ãƒ¬ã‚·ãƒ”ã‚’ç™ºä¿¡ã™ã‚‹ã€‚", icon: "ğŸœ" },
            { name: "æ—…è¡Œã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼", description: "ä¸–ç•Œä¸­ã®çµ¶æ™¯ã‚„æ—…ã®ãƒ’ãƒ³ãƒˆã‚’å…±æœ‰ã™ã‚‹ã€‚", icon: "âœˆï¸" },
            { name: "ãƒ•ã‚£ãƒƒãƒˆãƒã‚¹ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼", description: "å¥åº·çš„ãªãƒ©ã‚¤ãƒ•ã‚¹ã‚¿ã‚¤ãƒ«ã‚„ãƒˆãƒ¬ãƒ¼ãƒ‹ãƒ³ã‚°æ–¹æ³•ã‚’ææ¡ˆã™ã‚‹ã€‚", icon: "ğŸ’ª" },
        ];

        // SNSãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’è¡Œã†ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¿ã‚¤ãƒ—
        const reactionUserTypes = [
            { type: "ãƒ•ã‚¡ãƒƒã‚·ãƒ§ãƒ³å¥½ã", icon: "âœ¨" },
            { type: "ã‚°ãƒ«ãƒ¡ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼", icon: "ğŸ˜‹" },
            { type: "æ—…è¡Œãƒ–ãƒ­ã‚¬ãƒ¼", icon: "ğŸ—ºï¸" },
            { type: "ãƒ•ã‚£ãƒƒãƒˆãƒã‚¹æ„›å¥½å®¶", icon: "ğŸ‹ï¸â€â™€ï¸" },
            { type: "ãƒ†ãƒƒã‚¯ã‚ªã‚¿ã‚¯", icon: "ğŸ¤“" },
            { type: "ä¸€èˆ¬çš„ãªSNSãƒ¦ãƒ¼ã‚¶ãƒ¼", icon: "ğŸ‘¤" }
        ];

        // ç”»åƒã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ (è‰²å½©ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã¯å‰Šé™¤)
        const imageStyles = ["ç¾ä»£çš„ãªã‚¹ã‚¿ã‚¤ãƒ«", "ãƒŸãƒ‹ãƒãƒªã‚¹ãƒˆ", "ãƒªã‚¢ãƒ«ãªå†™çœŸ"];

        // APIå‘¼ã³å‡ºã—ã®ãƒªãƒˆãƒ©ã‚¤å›æ•° (æœ€å¤§10å›)
        const MAX_RETRIES = 10;
        // ãƒªãƒˆãƒ©ã‚¤é–“ã®å¾…æ©Ÿæ™‚é–“ (30ç§’)
        const RETRY_DELAY_MS = 30 * 1000;

        // å…¨ã¦ã®æŠ•ç¨¿ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒã™ã‚‹é…åˆ—
        let allPosts = [];
        let loadingTimerInterval; // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¿ã‚¤ãƒãƒ¼ã®IDã‚’ä¿æŒã™ã‚‹å¤‰æ•°

        /**
         * Function to display error messages
         * @param {string} message - Error message to display
         */
        const showErrorMessage = (message) => {
            errorMessageElement.textContent = message;
            errorMessageElement.classList.remove('hidden');
        };

        /**
         * Function to select a specified number of random influencers
         * @param {number} count - Number of influencers to select
         * @returns {Array} - Array of randomly selected influencer objects
         */
        const getRandomInfluencers = (count) => {
            const shuffled = [...influencerPersonas].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        };

        /**
         * Utility function to pause execution for a given duration.
         * @param {number} ms - Duration in milliseconds to sleep.
         */
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        /**
         * Resizes a base64 image to the specified dimensions using a canvas.
         * @param {string} base64Url - The base64 URL of the original image.
         * @param {number} targetWidth - The desired width.
         * @param {number} targetHeight - The desired height.
         * @returns {Promise<string>} - The base64 URL of the resized image.
         */
        const resizeImage = (base64Url, targetWidth, targetHeight) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    canvas.width = targetWidth;
                    canvas.height = targetHeight;

                    // ç”»åƒã®ç¸¦æ¨ªæ¯”ã‚’ç¶­æŒã—ãªãŒã‚‰ãƒ•ã‚£ãƒƒãƒˆã•ã›ã‚‹
                    const aspectRatio = img.width / img.height;
                    let drawWidth = targetWidth;
                    let drawHeight = targetHeight;

                    // æç”»ã•ã‚Œã‚‹ç”»åƒãŒæ ã‚’è¶…ãˆã‚‹å ´åˆã€æœ€å¤§ã®å¯¸æ³•ã‚’åˆã‚ã›ã‚‹
                    if (img.width > img.height) { // æ¨ªé•·ã®å ´åˆ
                        drawHeight = targetWidth / aspectRatio;
                        drawWidth = targetWidth;
                    } else if (img.height > img.width) { // ç¸¦é•·ã®å ´åˆ
                        drawWidth = targetHeight * aspectRatio;
                        drawHeight = targetHeight;
                    } else { // æ­£æ–¹å½¢ã®å ´åˆ
                        drawWidth = targetWidth;
                        drawHeight = targetHeight;
                    }

                    // æç”»ä½ç½®ã‚’ä¸­å¤®ã«èª¿æ•´
                    const xOffset = (targetWidth - drawWidth) / 2;
                    const yOffset = (targetHeight - drawHeight) / 2;

                    ctx.drawImage(img, xOffset, yOffset, drawWidth, drawHeight);
                    resolve(canvas.toDataURL('image/png'));
                };
                img.onerror = (error) => {
                    console.error("ç”»åƒãƒªã‚µã‚¤ã‚ºä¸­ã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:", error);
                    reject(new Error("ç”»åƒã®ãƒªã‚µã‚¤ã‚ºã«å¤±æ•—ã—ã¾ã—ãŸ: ç”»åƒã®èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼"));
                };
                img.src = base64Url;
            });
        };


        /**
         * Function to call AI image generation API
         * @param {string} prompt - Prompt for image generation
         * @returns {Promise<string>} - Base64 URL of the generated image
         */
        const generateImage = async (prompt) => {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKey}`;
            const payload = {
                instances: { prompt: prompt },
                parameters: { "sampleCount": 1 }
            };

            console.log('ç”»åƒç”ŸæˆAPIã«é€ã‚‹APIã‚­ãƒ¼ï¼ˆæœ«å°¾5æ–‡å­—ï¼‰:', apiKey.slice(-5));
            console.log('ç”»åƒç”ŸæˆAPIãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰:', JSON.stringify(payload, null, 2));

            for (let retryCount = 0; retryCount <= MAX_RETRIES; retryCount++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.warn(`ç”»åƒç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ (5åˆ†)ã€‚${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®ã€‚`);
                    controller.abort();
                }, 5 * 60 * 1000); // 5 minutes timeout

                try {
                    console.log(`ç”»åƒç”ŸæˆAPIã‚’å‘¼ã³å‡ºã—ä¸­... (${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®)`);
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId); // Clear timer on success
                    console.log('ç”»åƒç”ŸæˆAPIã‹ã‚‰ã®å¿œç­” (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹):', response.status);

                    let responseText = await response.text();
                    console.log('ç”»åƒç”ŸæˆAPIå¿œç­”ï¼ˆç”Ÿãƒ†ã‚­ã‚¹ãƒˆï¼‰:', responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));

                    if (!responseText) {
                        if (retryCount < MAX_RETRIES) {
                             console.warn(`APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})ã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                             await sleep(RETRY_DELAY_MS);
                             continue;
                        }
                        throw new Error(`APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})ã€‚`);
                    }

                    let result;
                    try {
                        result = JSON.parse(responseText);
                    } catch (jsonError) {
                        console.error('JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:', jsonError);
                        if (retryCount < MAX_RETRIES) {
                             console.warn(`APIå¿œç­”ã®JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                             await sleep(RETRY_DELAY_MS);
                             continue;
                        }
                        throw new Error(`APIå¿œç­”ã®JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ${jsonError.message}. å¿œç­”: ${responseText.substring(0, 200)}...`);
                    }

                    if (!response.ok) {
                        console.error('ç”»åƒç”ŸæˆAPIã‚¨ãƒ©ãƒ¼è©³ç´° (HTTPã‚¨ãƒ©ãƒ¼å¿œç­”):', JSON.stringify(result, null, 2));

                        if (response.status === 401) {
                            throw new Error(`ç”»åƒç”ŸæˆAPIã‚¨ãƒ©ãƒ¼ (401èªè¨¼ã‚¨ãƒ©ãƒ¼): APIã‚­ãƒ¼ãŒç„¡åŠ¹ã‹æœŸé™åˆ‡ã‚Œã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`);
                        } else if (retryCount < MAX_RETRIES) {
                            console.warn(`ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                            await sleep(RETRY_DELAY_MS);
                            continue;
                        } else {
                            throw new Error(`ç”»åƒç”ŸæˆAPIã‚¨ãƒ©ãƒ¼ (${response.status}): ${result.error?.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`);
                        }
                    }

                    if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                        console.log('ç”»åƒãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å–å¾—ã•ã‚Œã¾ã—ãŸã€‚');
                        return `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                    } else {
                        console.error('ç”»åƒãƒ‡ãƒ¼ã‚¿ãŒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
                        console.error('`predictions[0].bytesBase64Encoded` ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ç©ºã§ã—ãŸã€‚');
                        if (retryCount < MAX_RETRIES) {
                             console.warn(`ç”»åƒãƒ‡ãƒ¼ã‚¿ãŒå¿œç­”ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                             await sleep(RETRY_DELAY_MS);
                             continue;
                        }
                        throw new Error('APIãŒæœ‰åŠ¹ãªç”»åƒãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    console.error(`ç”»åƒç”Ÿæˆä¸­ã«ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã—ãŸ (${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®):`, error);
                    if (error.name === 'AbortError') {
                        throw new Error(`ç”»åƒç”ŸæˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ (æœ€å¤§5åˆ†)ã€‚APIãŒå¿œç­”ã—ã¾ã›ã‚“ã§ã—ãŸã€‚`);
                    }
                    if (retryCount < MAX_RETRIES && (error.message.includes('Failed to fetch') || error.name === 'TypeError' || error.message.includes('APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ') || error.message.includes('JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ'))) {
                        console.warn(`ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯/å¿œç­”ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                        await sleep(RETRY_DELAY_MS);
                        continue;
                    }
                    throw error;
                }
            }
            throw new Error(`ç”»åƒç”ŸæˆAPIãŒ${MAX_RETRIES + 1}å›ã®è©¦è¡Œå¾Œã«æˆåŠŸã—ã¾ã›ã‚“ã§ã—ãŸã€‚`);
        };

        /**
         * Function to call AI text generation API (Gemini) for text content.
         * @param {string} prompt - Prompt for text generation.
         * @returns {Promise<string>} - Generated text.
         */
        const generateText = async (prompt) => {
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = { contents: chatHistory };

            console.log('ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆAPIãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰:', JSON.stringify(payload, null, 2));

            for (let retryCount = 0; retryCount <= MAX_RETRIES; retryCount++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.warn(`ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ (1åˆ†)ã€‚${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®ã€‚`);
                    controller.abort();
                }, 60 * 1000); // 1 minute timeout

                try {
                    console.log(`ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆAPIã‚’å‘¼ã³å‡ºã—ä¸­... (${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®)`);
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);
                    console.log('ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆAPIã‹ã‚‰ã®å¿œç­” (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹):', response.status);

                    let responseText = await response.text();
                    console.log('ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆAPIå¿œç­”ï¼ˆç”Ÿãƒ†ã‚­ã‚¹ãƒˆï¼‰:', responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));

                    if (!responseText) {
                        if (retryCount < MAX_RETRIES) {
                             console.warn(`APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})ã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                             await sleep(RETRY_DELAY_MS);
                             continue;
                        }
                        throw new Error(`APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})ã€‚`);
                    }

                    let result;
                    try {
                        result = JSON.parse(responseText);
                    } catch (jsonError) {
                        console.error('JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:', jsonError);
                        if (retryCount < MAX_RETRIES) {
                             console.warn(`APIå¿œç­”ã®JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                             await sleep(RETRY_DELAY_MS);
                             continue;
                        }
                        throw new Error(`APIå¿œç­”ã®JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ${jsonError.message}. å¿œç­”: ${responseText.substring(0, 200)}...`);
                    }

                    if (!response.ok) {
                        console.error('ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆAPIã‚¨ãƒ©ãƒ¼è©³ç´° (HTTPã‚¨ãƒ©ãƒ¼å¿œç­”):', JSON.stringify(result, null, 2));
                        if (response.status === 401) {
                            throw new Error(`ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆAPIã‚¨ãƒ©ãƒ¼ (401èªè¨¼ã‚¨ãƒ©ãƒ¼): APIã‚­ãƒ¼ãŒç„¡åŠ¹ã‹æœŸé™åˆ‡ã‚Œã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`);
                        } else if (retryCount < MAX_RETRIES) {
                            console.warn(`ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                            await sleep(RETRY_DELAY_MS);
                            continue;
                        } else {
                            throw new Error(`ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆAPIã‚¨ãƒ©ãƒ¼ (${response.status}): ${result.candidates?.[0]?.content?.parts?.[0]?.text || result.error?.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`);
                        }
                    }

                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        console.log('ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å–å¾—ã•ã‚Œã¾ã—ãŸã€‚');
                        return result.candidates[0].content.parts[0].text;
                    } else {
                        console.error('ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãŒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
                        console.error('`candidates[0].content.parts[0].text` ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹ç©ºã§ã—ãŸã€‚');
                        if (retryCount < MAX_RETRIES) {
                             console.warn(`ãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãŒå¿œç­”ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                             await sleep(RETRY_DELAY_MS);
                             continue;
                        }
                        throw new Error('APIãŒæœ‰åŠ¹ãªãƒ†ã‚­ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    console.error(`ãƒ†ã‚­ã‚¹ãƒˆç”Ÿæˆä¸­ã«ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã—ãŸ (${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®):`, error);
                    if (error.name === 'AbortError') {
                        throw new Error(`ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ (æœ€å¤§1åˆ†)ã€‚APIãŒå¿œç­”ã—ã¾ã›ã‚“ã§ã—ãŸã€‚`);
                    }
                    if (retryCount < MAX_RETRIES && (error.message.includes('Failed to fetch') || error.name === 'TypeError' || error.message.includes('APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ') || error.message.includes('JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ'))) {
                        console.warn(`ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯/å¿œç­”ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                        await sleep(RETRY_DELAY_MS);
                        continue;
                    }
                    throw error;
                }
            }
            throw new Error(`ãƒ†ã‚­ã‚¹ãƒˆç”ŸæˆAPIãŒ${MAX_RETRIES + 1}å›ã®è©¦è¡Œå¾Œã«æˆåŠŸã—ã¾ã›ã‚“ã§ã—ãŸã€‚`);
        };


        /**
         * Function to call AI text generation API (Gemini) for structured reactions.
         * @param {string} imageConcept - The concept of the image to react to.
         * @param {string} influencerName - The name of the influencer who posted.
         * @param {string} captionText - The generated caption text for the post.
         * @returns {Promise<Array<Object>>} - Array of reaction objects (user_type, comment, rating).
         */
        const generateReactions = async (imageConcept, influencerName, captionText) => { // Removed influencerGender parameter
            const reactionPrompt = `ä»¥ä¸‹ã®ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼æŠ•ç¨¿ã®ç”»åƒã‚³ãƒ³ã‚»ãƒ—ãƒˆã¨ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³ã«å¯¾ã—ã¦ã€æ§˜ã€…ãªSNSãƒ¦ãƒ¼ã‚¶ãƒ¼è¦–ç‚¹ï¼ˆ${reactionUserTypes.map(u => u.type).join(', ')}ï¼‰ã‹ã‚‰ã€**5ã¤ã®çŸ­ã„ã‚³ãƒ¡ãƒ³ãƒˆ**ã¨ã€1ã‹ã‚‰5ã®è©•ä¾¡ç‚¹ï¼ˆé«˜ã„ã»ã©è‰¯ã„ï¼‰ã‚’ç”Ÿæˆã—ã¦ãã ã•ã„ã€‚å‡ºåŠ›ã¯JSONé…åˆ—ã®å½¢å¼ã§ã€å„ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ 'user_type', 'comment', 'rating' ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚’å«ã‚ã¦ãã ã•ã„ã€‚
            
            ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼å: ${influencerName}
            ç”»åƒã‚³ãƒ³ã‚»ãƒ—ãƒˆ: ${imageConcept}
            ã‚­ãƒ£ãƒ—ã‚·ãƒ§ãƒ³: ${captionText}`;
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
            const chatHistory = [{ role: "user", parts: [{ text: reactionPrompt }] }];
            const payload = { 
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "ARRAY",
                        items: {
                            type: "OBJECT",
                            properties: {
                                "user_type": { "type": "STRING" },
                                "comment": { "type": "STRING" },
                                "rating": { "type": "NUMBER" } // Number type for rating
                            },
                            "required": ["user_type", "comment", "rating"]
                        }
                    }
                }
            };

            console.log('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆAPIãƒªã‚¯ã‚¨ã‚¹ãƒˆãƒšã‚¤ãƒ­ãƒ¼ãƒ‰:', JSON.stringify(payload, null, 2));

            for (let retryCount = 0; retryCount <= MAX_RETRIES; retryCount++) {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    console.warn(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ (1åˆ†)ã€‚${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®ã€‚`);
                    controller.abort();
                }, 60 * 1000); // 1 minute timeout

                try {
                    console.log(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆAPIã‚’å‘¼ã³å‡ºã—ä¸­... (${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®)`);
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);
                    console.log('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆAPIã‹ã‚‰ã®å¿œç­” (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹):', response.status);

                    let responseText = await response.text();
                    console.log('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆAPIå¿œç­”ï¼ˆç”Ÿãƒ†ã‚­ã‚¹ãƒˆï¼‰:', responseText.substring(0, 500) + (responseText.length > 500 ? '...' : ''));

                    if (!responseText) {
                        if (retryCount < MAX_RETRIES) {
                             console.warn(`APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})ã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                             await sleep(RETRY_DELAY_MS);
                             continue;
                        }
                        throw new Error(`APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ (HTTPã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: ${response.status})ã€‚`);
                    }

                    let result;
                    try {
                        result = JSON.parse(responseText);
                    } catch (jsonError) {
                        console.error('JSONãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼:', jsonError);
                        if (retryCount < MAX_RETRIES) {
                             console.warn(`APIå¿œç­”ã®JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                             await sleep(RETRY_DELAY_MS);
                             continue;
                        }
                        throw new Error(`APIå¿œç­”ã®JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ${jsonError.message}. å¿œç­”: ${responseText.substring(0, 200)}...`);
                    }

                    if (!response.ok) {
                        console.error('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆAPIã‚¨ãƒ©ãƒ¼è©³ç´° (HTTPã‚¨ãƒ©ãƒ¼å¿œç­”):', JSON.stringify(result, null, 2));
                        if (response.status === 401) {
                            throw new Error(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆAPIã‚¨ãƒ©ãƒ¼ (401èªè¨¼ã‚¨ãƒ©ãƒ¼): APIã‚­ãƒ¼ãŒç„¡åŠ¹ã‹æœŸé™åˆ‡ã‚Œã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚`);
                        } else if (retryCount < MAX_RETRIES) {
                            console.warn(`ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                            await sleep(RETRY_DELAY_MS);
                            continue;
                        } else {
                            throw new Error(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆAPIã‚¨ãƒ©ãƒ¼ (${response.status}): ${result.candidates?.[0]?.content?.parts?.[0]?.text || result.error?.message || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`);
                        }
                    }
                    
                    // Validate the structure of the generated reactions
                    if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts && result.candidates[0].content.parts.length > 0) {
                        const reactions = JSON.parse(result.candidates[0].content.parts[0].text);
                        // Ensure exactly 5 reactions are returned, if not, fill or truncate
                        if (Array.isArray(reactions) && reactions.every(r => typeof r.user_type === 'string' && typeof r.comment === 'string' && typeof r.rating === 'number')) {
                            console.log('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒæ­£å¸¸ã«å–å¾—ã•ã‚Œã¾ã—ãŸã€‚');
                            // If fewer than 5, try to fill with generic ones, if more, truncate
                            while (reactions.length < 5) {
                                reactions.push({ user_type: "ä¸€èˆ¬çš„ãªSNSãƒ¦ãƒ¼ã‚¶ãƒ¼", comment: "ç´ æ•µãªæŠ•ç¨¿ã§ã™ã­ï¼", rating: Math.floor(Math.random() * 5) + 1 });
                            }
                            return reactions.slice(0, 5); // Ensure exactly 5
                        } else {
                            console.error('ç”Ÿæˆã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®æ§‹é€ ãŒä¸æ­£ã§ã™:', reactions);
                            if (retryCount < MAX_RETRIES) { // ãƒªãƒˆãƒ©ã‚¤æ¡ä»¶ã«è¿½åŠ 
                                console.warn(`ç”Ÿæˆã•ã‚ŒãŸãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®æ§‹é€ ãŒä¸æ­£ã§ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                                await sleep(RETRY_DELAY_MS);
                                continue;
                            }
                            throw new Error('APIãŒæœŸå¾…ã•ã‚Œã‚‹å½¢å¼ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã›ã‚“ã¾ã—ãŸã€‚');
                        }
                    } else {
                        console.error('ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒãƒ¬ã‚¹ãƒãƒ³ã‚¹ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
                        if (retryCount < MAX_RETRIES) { // ãƒªãƒˆãƒ©ã‚¤æ¡ä»¶ã«è¿½åŠ 
                            console.warn(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒå¿œç­”ã«å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                            await sleep(RETRY_DELAY_MS);
                            continue;
                        }
                        throw new Error('APIãŒæœ‰åŠ¹ãªãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã›ã‚“ã§ã—ãŸã€‚');
                    }
                } catch (error) {
                    clearTimeout(timeoutId);
                    console.error(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”Ÿæˆä¸­ã«ä¾‹å¤–ãŒç™ºç”Ÿã—ã¾ã—ãŸ (${retryCount + 1}/${MAX_RETRIES + 1}å›ç›®):`, error);
                    if (error.name === 'AbortError') {
                        throw new Error(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ (æœ€å¤§1åˆ†)ã€‚APIãŒå¿œç­”ã—ã¾ã›ã‚“ã§ã—ãŸã€‚`);
                    }
                    if (retryCount < MAX_RETRIES && (error.message.includes('Failed to fetch') || error.name === 'TypeError' || error.message.includes('APIãŒç©ºã®å¿œç­”ã‚’è¿”ã—ã¾ã—ãŸ') || error.message.includes('JSONãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ') || error.message.includes('æœŸå¾…ã•ã‚Œã‚‹å½¢å¼ã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¾ã›ã‚“ã§ã—ãŸ'))) {
                        console.warn(`ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯/å¿œç­”ãƒ‘ãƒ¼ã‚¹ã‚¨ãƒ©ãƒ¼/ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚${retryCount + 1}å›ç›®ã®ãƒªãƒˆãƒ©ã‚¤ã‚’ ${RETRY_DELAY_MS / 1000} ç§’å¾Œã«è©¦ã¿ã¾ã™...`);
                        await sleep(RETRY_DELAY_MS);
                        continue;
                    }
                    throw error;
                }
            }
            throw new Error(`ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ç”ŸæˆAPIãŒ${MAX_RETRIES + 1}å›ã®è©¦è¡Œå¾Œã«æˆåŠŸã—ã¾ã›ã‚“ã§ã—ãŸã€‚`);
        };


        /**
         * Function to fetch a single SNS post data (generate image and caption)
         * @param {object} influencer - Influencer object
         * @returns {Promise<object>} - Post data (name, icon, imageUrl, caption, imagePrompt, reactions, averageRating, timestamp)
         */
        const fetchPostData = async (influencer) => {
            let imageUrl = "https://placehold.co/600x400/CCCCCC/333333?text=ç”»åƒç”Ÿæˆä¸­..."; // Initial placeholder
            let caption = "æŠ•ç¨¿å†…å®¹ã‚’ç”Ÿæˆä¸­..."; // Initial placeholder, will be replaced by AI
            let reactions = [];
            let averageRating = 0;
            const timestamp = new Date(Date.now() - Math.floor(Math.random() * 86400000)).toLocaleString('ja-JP', {
                year: 'numeric', month: 'numeric', day: 'numeric',
                hour: '2-digit', minute: '2-digit'
            });

            // Randomly pick a style
            const randomStyle = imageStyles[Math.floor(Math.random() * imageStyles.length)];
            
            // Image generation prompt: Incorporate random style
            const imagePrompt = `${influencer.description}ã€${randomStyle}ã€ã‚½ãƒ¼ã‚·ãƒ£ãƒ«ãƒ¡ãƒ‡ã‚£ã‚¢æŠ•ç¨¿ã«æœ€é©ãªã‚³ãƒ³ãƒ‘ã‚¯ãƒˆãªå†™çœŸ`;
            
            // Caption generation prompt: Added instruction to avoid conversational phrases
            const captionPrompt = `ä»¥ä¸‹ã®ã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼ã®ã‚¿ã‚¤ãƒ—ã¨èª¬æ˜ã«åŸºã¥ã„ã¦ã€çŸ­ã„SNSæŠ•ç¨¿æ–‡ã‚’æ›¸ã„ã¦ãã ã•ã„ã€‚ãƒãƒƒã‚·ãƒ¥ã‚¿ã‚°ã‚’2ã€œ3å€‹å«ã‚ã¦ãã ã•ã„ã€‚ã€Œã¯ã„ã€æ‰¿çŸ¥ã„ãŸã—ã¾ã—ãŸã€ã®ã‚ˆã†ãªã€å¯¾è©±å‹ã®å†’é ­æ–‡ã¯å«ã‚ãªã„ã§ãã ã•ã„ã€‚\n\nã‚¤ãƒ³ãƒ•ãƒ«ã‚¨ãƒ³ã‚µãƒ¼: ${influencer.name}\nèª¬æ˜: ${influencer.description}\n\næŠ•ç¨¿æ–‡:`;
            
            try {
                console.log(`--- ${influencer.name} ã®æŠ•ç¨¿ç”Ÿæˆã‚’é–‹å§‹ ---`);
                // Generate image
                const generatedRawImageUrl = await generateImage(imagePrompt);

                // Resize the generated image to 512x512
                try {
                    imageUrl = await resizeImage(generatedRawImageUrl, 512, 512); // Resize to 512x512
                    console.log('ç”»åƒã‚’512x512ã«ãƒªã‚µã‚¤ã‚ºã—ã¾ã—ãŸã€‚');
                } catch (resizeError) {
                    console.error('ç”»åƒã®ãƒªã‚µã‚¤ã‚ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', resizeError);
                    // ãƒªã‚µã‚¤ã‚ºå¤±æ•—æ™‚ã¯å…ƒã®ç”»åƒURLã‚’ä½¿ç”¨ã™ã‚‹ã‹ã€ã‚¨ãƒ©ãƒ¼ç”»åƒã‚’è¡¨ç¤ºã™ã‚‹
                    imageUrl = "https://placehold.co/512x512/FF0000/FFFFFF?text=ãƒªã‚µã‚¤ã‚ºå¤±æ•—"; // Placeholder for failed resize
                    // ã‚‚ã—å…ƒã®ç”»åƒURLã‚‚ç„¡åŠ¹ãªå ´åˆã‚’è€ƒæ…®ã—ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®placeholderã‚’ä½¿ç”¨
                    if (!generatedRawImageUrl) {
                         imageUrl = "https://placehold.co/600x400/FF0000/FFFFFF?text=ç”Ÿæˆå¤±æ•—"; // Fallback to original generation error placeholder
                    } else {
                        // ãƒªã‚µã‚¤ã‚ºã«å¤±æ•—ã—ãŸãŒã€å…ƒã®ç”»åƒã¯å–å¾—ã§ãã¦ã„ã‚‹å ´åˆ
                        imageUrl = generatedRawImageUrl;
                        console.warn("ç”»åƒãƒªã‚µã‚¤ã‚ºå¤±æ•—ã€‚å…ƒã®ç”»åƒã‚’è¡¨ç¤ºã—ã¾ã™ã€‚");
                    }
                }
                
                // Generate main caption
                caption = await generateText(captionPrompt); 
                // Generate reactions (pass imagePrompt AND captionText)
                reactions = await generateReactions(imagePrompt, influencer.name, caption);
                
                // Calculate average rating
                if (reactions.length > 0) {
                    const totalRating = reactions.reduce((sum, r) => sum + r.rating, 0);
                    averageRating = parseFloat((totalRating / reactions.length).toFixed(1)); // Round to 1 decimal place
                }

                console.log(`--- ${influencer.name} ã®æŠ•ç¨¿ç”ŸæˆãŒå®Œäº† ---`);
            } catch (error) {
                console.error(`æŠ•ç¨¿ç”Ÿæˆã‚¨ãƒ©ãƒ¼ (${influencer.name}):`, error);
                imageUrl = "https://placehold.co/600x400/FF0000/FFFFFF?text=ç”Ÿæˆå¤±æ•—"; // Error image
                caption = `ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸ: ${error.message}`; // Error caption
                reactions = [{ user_type: "ã‚·ã‚¹ãƒ†ãƒ ", comment: "ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚", rating: 0 }];
                averageRating = 0;
                // Only show overall error message once
                if (errorMessageElement.classList.contains('hidden')) {
                     showErrorMessage('ä¸€éƒ¨ã®æŠ•ç¨¿ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚è©³ç´°ã«ã¤ã„ã¦ã¯ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                }
            }

            return {
                name: influencer.name,
                icon: influencer.icon,
                imageUrl: imageUrl,
                caption: caption,
                imagePrompt: imagePrompt, // Store original image prompt
                reactions: reactions,
                averageRating: averageRating,
                timestamp: timestamp
            };
        };

        /**
         * Function to render a post element to the DOM
         * @param {object} postData - Post data
         * @param {number} rank - Rank of the post
         */
        const renderPost = (postData, rank, totalPosts) => { // Added totalPosts parameter
            const postElement = document.createElement('div');
            postElement.className = 'bg-white rounded-xl shadow-md p-4 mb-4 transform hover:scale-105 transition-transform duration-300 ease-in-out';
            
            // Reactions display
            const reactionsHtml = postData.reactions.map(r => `
                <div class="flex items-start text-sm bg-gray-50 p-2 rounded-lg mb-1">
                    <span class="mr-2">${reactionUserTypes.find(u => u.type === r.user_type)?.icon || 'ğŸ’¬'}</span>
                    <p class="text-gray-700">
                        <span class="font-semibold">${r.user_type}:</span> ${r.comment}
                        <span class="text-yellow-500 ml-1">(${r.rating} / 5)</span>
                    </p>
                </div>
            `).join('');


            postElement.innerHTML = `
                <div class="flex items-center mb-3">
                    <span class="text-4xl mr-3">${postData.icon}</span>
                    <div>
                        <p class="font-bold text-gray-800 text-lg">${postData.name}</p>
                        <p class="text-gray-500 text-xs">${postData.timestamp}</p>
                    </div>
                </div>
                <div class="bg-gray-200 rounded-lg overflow-hidden mb-3 relative group flex items-center justify-center" style="width: 400px; height: 400px; margin-left: auto; margin-right: auto;">
                    <img src="${postData.imageUrl}" alt="${postData.name}ã®æŠ•ç¨¿ç”»åƒ" class="object-contain w-full h-full rounded-lg" onerror="this.onerror=null;this.src='https://placehold.co/400x400/FF0000/FFFFFF?text=ç”»åƒã®èª­ã¿è¾¼ã¿å¤±æ•—';" />
                    <div class="absolute inset-0 bg-black bg-opacity-75 flex flex-col items-center justify-center p-4 text-white text-sm opacity-0 group-hover:opacity-100 transition-opacity duration-300 pointer-events-none rounded-lg text-center">
                        <p class="font-bold mb-2">ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆ:</p>
                        <p class="break-words">${postData.imagePrompt}</p>
                    </div>
                </div>
                <p class="text-gray-700 mb-3 whitespace-pre-wrap">${postData.caption}</p>
                <div class="flex items-center text-gray-600 text-sm mb-3">
                    å¹³å‡è©•ä¾¡: <span class="text-yellow-500 font-bold ml-1">${postData.averageRating} / 5</span>
                    <span class="ml-3 px-2 py-0.5 bg-yellow-400 text-white rounded-full text-xs font-semibold shadow-md">#${rank}/${totalPosts}</span>
                </div>
                <div class="mt-4 border-t border-gray-200 pt-3">
                    <h4 class="font-semibold text-gray-700 mb-2">ã¿ã‚“ãªã®ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³:</h4>
                    ${reactionsHtml || '<p class="text-gray-500 text-sm">ã¾ã ãƒªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒã‚ã‚Šã¾ã›ã‚“ã€‚</p>'}
                </div>
            `;
            feedContainer.appendChild(postElement);
        };

        /**
         * Re-renders the entire feed based on the current `allPosts` array, but without sorting.
         */
        const renderFeed = () => {
            // Clear existing posts, but keep loading messages and error messages
            const existingPostElements = feedContainer.querySelectorAll('.bg-white.rounded-xl.shadow-md');
            existingPostElements.forEach(el => el.remove());

            // Calculate ranks based on averageRating (highest rating = rank #1)
            // Create a temporary sorted array to determine ranks
            const sortedPosts = [...allPosts].sort((a, b) => b.averageRating - a.averageRating);
            
            // Assign ranks to original posts
            const totalPosts = allPosts.length;
            allPosts.forEach(post => {
                const rankIndex = sortedPosts.findIndex(p => p === post); // Find its position in the sorted array
                post.ratingRank = rankIndex + 1; // Store the rating-based rank
            });

            // Render all posts in their original (generation) order
            allPosts.forEach((post) => {
                renderPost(post, post.ratingRank, totalPosts); // Pass calculated ratingRank and totalPosts
            });
        };


        /**
         * Function to load more posts
         * Processes each post sequentially with a delay to mitigate API rate limits.
         * @param {number} count - Number of posts to load
         */
        const loadMorePosts = async (count = 3) => { // Default to 3 posts
            loadMoreButton.disabled = true; // Disable button
            
            const loadingIndicator = document.createElement('p');
            loadingIndicator.id = 'loadingIndicator'; // IDã‚’è¿½åŠ 
            loadingIndicator.className = 'text-center text-blue-600 font-medium my-4 loading-indicator';
            loadingIndicator.innerHTML = `
                <svg class="animate-spin inline-block h-5 w-5 mr-3 text-blue-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>æ–°ã—ã„æŠ•ç¨¿ã‚’ç”Ÿæˆä¸­...</span>
                <br>
                <span class="text-sm text-gray-700 mt-2 block">
                    ç”Ÿæˆã«ã¯2åˆ†ä»¥ä¸Šã‹ã‹ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚<br>
                    APIKeyã®ä½¿ç”¨çŠ¶æ³ã‚„ã‚¢ã‚¯ã‚»ã‚¹çŠ¶æ³ã«ã‚ˆã£ã¦ã¯ã€ç”»åƒã‚„æŠ•ç¨¿ãŒç”Ÿæˆã•ã‚Œãªã„ã“ã¨ãŒã‚ã‚Šã¾ã™ã€‚<br>
                    â€»èª­ã¿è¾¼ã¿æ©Ÿèƒ½ã¯äºˆç®—ã®é–¢ä¿‚ã§ãƒ€ãƒŸãƒ¼ã«ãªã£ã¦ã„ã¾ã™ã€‚
                </span>
                <br>
                <span id="elapsedTime" class="text-sm text-gray-800 font-semibold">çµŒéæ™‚é–“: 0ç§’</span>
            `;
            // ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’ãƒ•ã‚£ãƒ¼ãƒ‰ã®æœ«å°¾ã«è¿½åŠ 
            feedContainer.appendChild(loadingIndicator);

            let secondsElapsed = 0;
            const startTime = Date.now();
            // ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹
            loadingTimerInterval = setInterval(() => {
                secondsElapsed = Math.floor((Date.now() - startTime) / 1000);
                const minutes = Math.floor(secondsElapsed / 60);
                const seconds = secondsElapsed % 60;
                document.getElementById('elapsedTime').textContent = `çµŒéæ™‚é–“: ${minutes}åˆ†${seconds}ç§’`;
            }, 1000);

            errorMessageElement.classList.add('hidden'); // Hide existing error message

            const influencersToLoad = getRandomInfluencers(count);

            try {
                for (const influencer of influencersToLoad) {
                    const post = await fetchPostData(influencer); // Wait for each post
                    allPosts.push(post); // Add new post to the allPosts array
                    await sleep(1500); // Add a 1.5-second delay after each post generation
                }
                renderFeed(); // Re-render the entire feed
            } catch (error) {
                console.error("æŠ•ç¨¿ã®èª­ã¿è¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼:", error);
                showErrorMessage('æŠ•ç¨¿ã®èª­ã¿è¾¼ã¿ä¸­ã«å•é¡ŒãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚' + error.message);
            } finally {
                clearInterval(loadingTimerInterval); // ã‚¿ã‚¤ãƒãƒ¼ã‚’åœæ­¢
                loadingIndicator.remove(); // Remove loading indicator
                loadMoreButton.disabled = false; // Re-enable button
            }
        };

        // Application initialization
        const initApp = async () => {
            await loadMorePosts(3); // Load 3 initial posts
        };

        // Event listeners
        document.addEventListener('DOMContentLoaded', initApp); // Initialize app after DOM load
        loadMoreButton.addEventListener('click', () => loadMorePosts(3)); // Load 3 more posts on button click
    </script>
</body>
</html>
